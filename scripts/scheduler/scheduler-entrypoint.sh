#!/bin/sh
set -e

echo "[scheduler] Starting scheduler container..."

# タイムゾーン設定 + curl インストール（Docker API 用）
apk add --no-cache tzdata curl > /dev/null 2>&1
cp /usr/share/zoneinfo/${SCHEDULE_TIMEZONE:-Asia/Tokyo} /etc/localtime
echo "${SCHEDULE_TIMEZONE:-Asia/Tokyo}" > /etc/timezone

# rcon-cli のインストール
# gorcon/rcon-cli のバイナリを取得
echo "[scheduler] Installing rcon-cli..."
RCON_CLI_VERSION="0.10.3"
ARCH=$(uname -m)
case "$ARCH" in
  x86_64)  RCON_ARCH="amd64" ;;
  aarch64) RCON_ARCH="arm64" ;;
  *)       RCON_ARCH="amd64" ;;
esac
wget -q "https://github.com/gorcon/rcon-cli/releases/download/v${RCON_CLI_VERSION}/rcon-${RCON_CLI_VERSION}-${RCON_ARCH}_linux.tar.gz" -O /tmp/rcon.tar.gz
tar xzf /tmp/rcon.tar.gz -C /tmp/
cp /tmp/rcon-${RCON_CLI_VERSION}-${RCON_ARCH}_linux/rcon /usr/local/bin/rcon-cli
chmod +x /usr/local/bin/rcon-cli
rm -rf /tmp/rcon*

# RCON接続用の関数をエクスポート
cat > /etc/profile.d/rcon.sh << 'RCON_FUNC'
rcon_cmd() {
  rcon-cli --address "${RCON_HOST:-mc}:${RCON_PORT:-25575}" --password "${RCON_PASSWORD:-changeme}" "$@"
}
RCON_FUNC

# RCON送信用のヘルパースクリプト
cat > /usr/local/bin/rcon-send << 'EOF'
#!/bin/sh
rcon-cli --address "${RCON_HOST:-mc}:${RCON_PORT:-25575}" --password "${RCON_PASSWORD:-changeme}" "$@"
EOF
chmod +x /usr/local/bin/rcon-send

# Docker API ヘルパースクリプト
# Docker Socket 経由で mc コンテナを制御する
cat > /usr/local/bin/docker-mc << 'EOF'
#!/bin/sh
# 使い方: docker-mc start|stop|status
# Docker Engine API を使って mc コンテナを制御する
DOCKER_SOCKET="/var/run/docker.sock"
CONTAINER="mc"

case "$1" in
  stop)
    # t=30: 30秒の猶予後に SIGKILL（通常は SIGTERM で先にグレースフル停止される）
    HTTP_CODE=$(curl -s --unix-socket "$DOCKER_SOCKET" \
      -X POST "http://localhost/containers/${CONTAINER}/stop?t=30" \
      -o /dev/null -w "%{http_code}" 2>/dev/null || echo "000")
    case "$HTTP_CODE" in
      204|304) exit 0 ;;  # 204=stopped, 304=already stopped
      *)       exit 1 ;;
    esac
    ;;
  start)
    HTTP_CODE=$(curl -s --unix-socket "$DOCKER_SOCKET" \
      -X POST "http://localhost/containers/${CONTAINER}/start" \
      -o /dev/null -w "%{http_code}" 2>/dev/null || echo "000")
    case "$HTTP_CODE" in
      204|304) exit 0 ;;  # 204=started, 304=already running
      *)       exit 1 ;;
    esac
    ;;
  status)
    # running / exited / ... を返す
    curl -sf --unix-socket "$DOCKER_SOCKET" \
      "http://localhost/containers/${CONTAINER}/json" 2>/dev/null \
      | sed -n 's/.*"Status":"\([^"]*\)".*/\1/p'
    ;;
  *)
    echo "Usage: docker-mc start|stop|status" >&2
    exit 1
    ;;
esac
EOF
chmod +x /usr/local/bin/docker-mc

echo "[scheduler] Generating crontab..."

# crontab を動的に生成
CRONTAB_FILE="/etc/crontabs/root"
echo "# Auto-generated by scheduler-entrypoint.sh" > "$CRONTAB_FILE"

# -------------------------------------------
# 日次再起動の cron エントリ
# -------------------------------------------
if [ "${RESTART_ENABLED}" = "true" ]; then
  RESTART_HOUR=$(echo "${RESTART_TIME:-04:30}" | cut -d: -f1 | sed 's/^0//')
  RESTART_MIN=$(echo "${RESTART_TIME:-04:30}" | cut -d: -f2 | sed 's/^0//')

  # 事前通知の cron エントリを生成
  WARN_MINUTES="${RESTART_WARN_MINUTES:-10,5,1}"
  IFS=','
  for warn_min in $WARN_MINUTES; do
    warn_min=$(echo "$warn_min" | tr -d ' ')

    # 1分前はループ後に特別メッセージとして生成するのでスキップ
    if [ "$warn_min" = "1" ]; then
      continue
    fi

    # 通知時刻を計算
    total_min=$((RESTART_HOUR * 60 + RESTART_MIN - warn_min))
    if [ "$total_min" -lt 0 ]; then
      total_min=$((total_min + 1440))
    fi
    notify_hour=$((total_min / 60))
    notify_min=$((total_min % 60))

    echo "${notify_min} ${notify_hour} * * * /usr/local/bin/rcon-send \"say §e[自動再起動] ${warn_min}分後にサーバーを再起動します\"" >> "$CRONTAB_FILE"
  done
  unset IFS

  # 1分前の特別メッセージ（赤色で緊急感を出す）
  total_min=$((RESTART_HOUR * 60 + RESTART_MIN - 1))
  if [ "$total_min" -lt 0 ]; then
    total_min=$((total_min + 1440))
  fi
  notify_hour=$((total_min / 60))
  notify_min=$((total_min % 60))
  echo "${notify_min} ${notify_hour} * * * /usr/local/bin/rcon-send \"say §c[自動再起動] 1分後にサーバーを再起動します。安全な場所でログアウトしてください\"" >> "$CRONTAB_FILE"

  # 再起動実行
  echo "${RESTART_MIN} ${RESTART_HOUR} * * * /scripts/daily-restart.sh >> /var/log/scheduler.log 2>&1" >> "$CRONTAB_FILE"

  echo "[scheduler] Daily restart enabled at ${RESTART_TIME}"
fi

# -------------------------------------------
# スケジュール制御の cron エントリ
# -------------------------------------------
SCHEDULE_MODE="${SCHEDULE_MODE:-always}"

if [ "$SCHEDULE_MODE" = "timed" ] || [ "$SCHEDULE_MODE" = "custom" ]; then
  START_HOUR=$(echo "${SCHEDULE_START_TIME:-18:00}" | cut -d: -f1 | sed 's/^0//')
  START_MIN=$(echo "${SCHEDULE_START_TIME:-18:00}" | cut -d: -f2 | sed 's/^0//')
  STOP_HOUR=$(echo "${SCHEDULE_STOP_TIME:-00:00}" | cut -d: -f1 | sed 's/^0//')
  STOP_MIN=$(echo "${SCHEDULE_STOP_TIME:-00:00}" | cut -d: -f2 | sed 's/^0//')

  # 曜日指定の処理
  CRON_DAYS="*"
  if [ "$SCHEDULE_MODE" = "custom" ] && [ -n "$SCHEDULE_DAYS" ]; then
    # mon,tue,wed... → 1,2,3... に変換
    CRON_DAYS=$(echo "$SCHEDULE_DAYS" | sed \
      -e 's/mon/1/gi' -e 's/tue/2/gi' -e 's/wed/3/gi' \
      -e 's/thu/4/gi' -e 's/fri/5/gi' -e 's/sat/6/gi' \
      -e 's/sun/0/gi')
  fi

  # 起動ジョブ（Docker API で mc コンテナを起動）
  cat >> "$CRONTAB_FILE" << STARTJOB
${START_MIN} ${START_HOUR} * * ${CRON_DAYS} /scripts/schedule-start.sh >> /var/log/scheduler.log 2>&1
STARTJOB

  # 停止ジョブ（RCON 通知 → save → Docker API で mc コンテナを停止）
  cat >> "$CRONTAB_FILE" << STOPJOB
${STOP_MIN} ${STOP_HOUR} * * ${CRON_DAYS} /scripts/schedule-stop.sh >> /var/log/scheduler.log 2>&1
STOPJOB

  echo "[scheduler] Schedule mode: ${SCHEDULE_MODE}"
  echo "[scheduler]   Start: ${SCHEDULE_START_TIME}, Stop: ${SCHEDULE_STOP_TIME}"
  [ -n "$SCHEDULE_DAYS" ] && echo "[scheduler]   Days: ${SCHEDULE_DAYS}"
fi

echo "[scheduler] Generated crontab:"
cat "$CRONTAB_FILE"

# ログファイルの初期化
touch /var/log/scheduler.log

echo "[scheduler] Starting crond..."
exec crond -f -l 2
